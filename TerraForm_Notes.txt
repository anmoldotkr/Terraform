
# ğŸŒ Terraform Basics

## ğŸ”¹ What is Terraform?

Terraform is an **Infrastructure as Code (IaC)** tool created by **HashiCorp**.
It allows you to define, provision, and manage infrastructure in a declarative way.

* Configuration files can be written in:

  * **HCL (HashiCorp Configuration Language)** â†’ commonly used (`.tf` files)
  * **JSON**

---

## ğŸ”¹ What is HashiCorp?

HashiCorp is a software company that builds tools for cloud infrastructure management, such as:

* Terraform (IaC)
* Vault (secrets management)
* Consul (service networking)
* Nomad (workload orchestration)

---

## ğŸ”¹ What is HCL?

HCL (**HashiCorp Configuration Language**) is a domain-specific language used to write Terraform configuration files.

* File extension: **`.tf`**
* Designed to be **human-readable & machine-friendly**

---

## ğŸ”¹ Why Terraform?

### ğŸš« Without Terraform (Manual Setup)

* You log in to AWS Console
* Create resources manually (EC2, RDS, S3, IAM, Security Groups)
* Repeat for staging, production, etc.
* Any change requires repeating steps â†’ **error-prone & time-consuming**

### âœ… With Terraform (Automated Setup)

* Define resources in code
* Reuse across environments (Dev, Stage, Prod)
* Version control infra configs
* Run once â†’ deploy automatically

---

## ğŸ”¹ Terraform Syntax

### General Syntax

```hcl
block_type "resource_type" "resource_name" {
  argument1 = value
  argument2 = value
}
```

* **Block** â†’ Top-level structure (e.g., `resource`, `provider`, `variable`)
* **Arguments** â†’ Define values inside a block (e.g., `bucket`, `filename`)
* **Attributes** â†’ Values available **after** resource creation (e.g., ARN of an S3 bucket)

---

## ğŸ”¹ Example 1: Create Local File

```hcl
resource "local_file" "my_file" {
  filename = "automate.txt"
  content  = "This text file is created by terraform"
}
```

### Notes:

* **resource** â†’ block type
* **local\_file** â†’ resource type (from **local provider**)
* **my\_file** â†’ resource name (must be unique within the module)
* `filename` & `content` â†’ arguments

---

## ğŸ”¹ Terraform Commands

1. `terraform init` â†’ Initialize provider plugins
2. `terraform validate` â†’ Check syntax
3. `terraform plan` â†’ Preview changes
4. `terraform apply` â†’ Apply changes (creates resources)
5. `terraform destroy` â†’ Delete resources

---

## ğŸ”¹ Example 2: Create AWS S3 Bucket

### Prerequisites:

* AWS CLI installed & configured
* AWS provider set up in Terraform

### `provider.tf` (to define cloud provider)

```hcl
provider "aws" {
  region = "us-east-1"
}
```

### `s3.tf` (to create bucket)

```hcl
resource "aws_s3_bucket" "mybkt" {
  bucket = "my-terraform-bucket"
}
```

---

## ğŸ”¹ Why `provider.tf`?

* Defines which provider Terraform should use (AWS, GCP, Azure, etc.)
* Without it, Terraform wonâ€™t know where to create resources

---

## ğŸ”¹ File Organization

* Not mandatory, but best practice:

  * `provider.tf` â†’ provider config
  * `variables.tf` â†’ input variables
  * `main.tf` â†’ resources
  * `terraform.tfvars` â†’ variable values
  * `outputs.tf` â†’ outputs

---

## ğŸ”¹ String Interpolation

Used to insert **dynamic values** into strings:

```hcl
resource "aws_s3_bucket" "mybkt" {
  bucket = "my-terraform-${var.environment}-bucket"
}
```

If `var.environment = "dev"` â†’ bucket = `my-terraform-dev-bucket`

---

## ğŸ”¹ Variables

Make code reusable and dynamic.

```hcl
variable "environment" {
  type    = string
  default = "dev"
}
```

Usage: `${var.environment}`

---

## ğŸ”¹ Count

Used to create multiple resources dynamically.

```hcl
resource "aws_instance" "servers" {
  count = 3
  ami   = "ami-123456"
  type  = "t2.micro"
}
```

* Creates **3 EC2 instances**
* `count.index` â†’ current index (starts at 0)

---

## ğŸ”¹ element() Function

Selects an item from a list by index.

```hcl
variable "cidr_blocks" {
  default = ["10.0.1.0/24", "10.0.2.0/24"]
}

resource "aws_subnet" "example" {
  count      = 2
  cidr_block = element(var.cidr_blocks, count.index)
}
```

* Subnet 0 â†’ `10.0.1.0/24`
* Subnet 1 â†’ `10.0.2.0/24`

---

# ğŸ¯ Quick Recap

* **Terraform** = IaC tool by HashiCorp
* **HCL** = Language to write `.tf` files
* **Blocks** = Building units (`resource`, `provider`, `variable`)
* **Arguments** = Defined before execution
* **Attributes** = Computed after execution
* **Commands** = init â†’ validate â†’ plan â†’ apply â†’ destroy
* **Best Practice** = Organize files (`provider.tf`, `main.tf`, etc.)


# Loops in Terraform
1. count (simplest Loop)
- creates multiple copies of the same resource.
- Use count.index (starts at 0).

Example create 3 EC2:
resource "aws_instance" "server"{
  count = 3
  ami  = "ami-12345"
  instance_type  = "t2.micro"
  tags = {
    Name = "server-${count.index}"
  }
}

output: server-0,server-1,server-2

2. for_each (loop over maps or sets)
- Better than count when you want to work with named items instead of indexes.

variable "bucket_name" {
  default = ["dev-bucket", "stage-bucket", "prod-bucket"]
}

resource "aws_s3_bucket" "ex" {
  for_each = toset(var.bucketname)
  bucket = each.value
}
**Meta-arguments** are special arguments you can use with resources, modules, and other Terraform blocks. They donâ€™t directly configure a resource itself, but instead control **how Terraform manages that resource**.

Some common **meta-arguments** in Terraform:

1. **`count`**

   * Lets you create multiple instances of the same resource.

   ```hcl
   resource "aws_instance" "example" {
     count = 3
     ami           = "ami-123456"
     instance_type = "t2.micro"
   }
   ```

   â†’ Creates 3 EC2 instances.

---

2. **`for_each`**

   * Similar to `count`, but works with maps or sets of strings.

   ```hcl
   resource "aws_s3_bucket" "example" {
     for_each = toset(["logs", "data", "images"])
     bucket   = "${each.key}-bucket"
   }
   ```

   â†’ Creates 3 buckets with names `logs-bucket`, `data-bucket`, `images-bucket`.

---

3. **`provider`**

   * Lets you choose which provider configuration to use.

   ```hcl
   resource "aws_instance" "example" {
     provider      = aws.us_east
     ami           = "ami-123456"
     instance_type = "t2.micro"
   }
   ```

---

4. **`depends_on`**

   * Explicitly sets dependencies between resources.

   ```hcl
   resource "aws_instance" "example" {
     ami           = "ami-123456"
     instance_type = "t2.micro"
     depends_on    = [aws_s3_bucket.example]
   }
   ```

---

5. **`lifecycle`**

   * Controls how Terraform handles resource updates/deletions.

   ```hcl
   resource "aws_instance" "example" {
     ami           = "ami-123456"
     instance_type = "t2.micro"

     lifecycle {
       prevent_destroy = true
       ignore_changes  = [tags]
     }
   }
   ```

---

âœ… In short: **Meta-arguments are special arguments that modify Terraformâ€™s behavior when creating, updating, or destroying resources.**

################ Terraform state Management Question's: ###################
--------------------------------------------------------------------------------
 â€œWhat Happens When You Delete a Resource Manuallyâ€

**What you did:**

* Deleted the S3 bucket manually from the AWS Console.
* Then ran `terraform plan` or `terraform apply`.

**What happened:**

* Terraform refreshed its state and noticed the bucket no longer exists in AWS.
* It removed that bucket from its state automatically.
* The plan showed a **create action (`+`)**, not a destroy (`-`), because the bucket was already gone.
* On `apply`, Terraform recreated the bucket to match your configuration.

**What you learned:**

* Terraform **trusts its state file** but refreshes it before planning.
* Manual changes in AWS cause **drift**.
* When Terraform detects a missing resource, it simply **recreates** it.
* The `-` destroy action appears only when *you remove the resource from your Terraform code*, not when it disappears in AWS.

---

So in short:

> **If AWS changes manually â†’ Terraform fixes it by recreating.
> If Terraform code changes â†’ Terraform plans a destroy or update.**


------
Perfect ğŸ‘ â€” hereâ€™s how you can phrase the **ideal, interview-ready answer** to that question.

---

### ğŸ§© Question

> I originally had a Terraform configuration that created one S3 bucket (`terra-st-s3`).
> Later, I deleted that resource block from my Terraform code and replaced it with a `for_each` loop to create two new buckets (`terra-st-s3-dev` and `terra-st-s3-prod`).
>
> When I ran `terraform plan`, Terraform showed that it would delete the old bucket and create the new ones.
>
> My question is:
> **Does Terraform decide to delete the old bucket and create the new ones based on the Terraform state file?**

---

### âœ… Ideal Answer

Yes â€” Terraform makes those decisions **based entirely on the Terraform state file**.

Hereâ€™s how it works step-by-step:

1. **Terraform state** is the source of truth that records which resources Terraform currently manages â€” including their IDs, attributes, and metadata.
2. When you run `terraform plan`, Terraform compares two things:

   * Your **current configuration files (.tf)** â†’ what you *want* to exist
   * Your **state file (terraform.tfstate)** â†’ what Terraform *believes* currently exists
3. In your case:

   * The old bucket (`terra-st-s3`) existed in the state file but was no longer defined in your configuration â†’ Terraform planned to **destroy** it.
   * The two new buckets (`terra-st-s3-dev` and `terra-st-s3-prod`) were in your configuration but not in the state file â†’ Terraform planned to **create** them.
4. After `terraform apply`, Terraform updated the state file â€” removing the old bucketâ€™s entry and adding entries for the new ones.

So yes:

> **Terraform uses the state file to understand the current known infrastructure, detect differences between configuration and reality, and plan the necessary actions (create, update, or destroy) to make them match.**

---

### ğŸ’¬ Optional one-liner summary

> Terraform compares your configuration with its state file to decide what to create, modify, or destroy â€” the state is its â€œmemoryâ€ of managed infrastructure.

---

